# SPDX-License-Identifier: GPL-2.0

config EARLY_PRINTK
	bool "Early printk" if EXPERT
	depends on SYS_HAS_EARLY_PRINTK || DEBUG_LL
	default y
	help
	  This option enables special console drivers which allow the kernel
	  to print messages very early in the bootup process.

	  This is useful for kernel debugging when your machine crashes very
	  early before the console code is initialized. For normal operation,
	  it is not recommended because it looks ugly on some machines and
	  doesn't cooperate with an X server. You should normally say N here,
	  unless you want to debug such a crash.

config EARLY_PRINTK_8250
	bool
	depends on EARLY_PRINTK && USE_GENERIC_EARLY_PRINTK_8250
	default y
	help
	  "8250/16550 and compatible serial early printk driver"
	  If you say Y here, it will be possible to use a 8250/16550 serial
	  port as the boot console.

config USE_GENERIC_EARLY_PRINTK_8250
	bool

config CMDLINE_BOOL
	bool "Built-in kernel command line"
	help
	  For most systems, it is firmware or second stage bootloader that
	  by default specifies the kernel command line options.  However,
	  it might be necessary or advantageous to either override the
	  default kernel command line or add a few extra options to it.
	  For such cases, this option allows you to hardcode your own
	  command line options directly into the kernel.  For that, you
	  should choose 'Y' here, and fill in the extra boot arguments
	  in CONFIG_CMDLINE.

	  The built-in options will be concatenated to the default command
	  line if CMDLINE_OVERRIDE is set to 'N'. Otherwise, the default
	  command line will be ignored and replaced by the built-in string.

	  Most MIPS systems will normally expect 'N' here and rely upon
	  the command line from the firmware or the second-stage bootloader.

config CMDLINE
	string "Default kernel command string"
	depends on CMDLINE_BOOL
	help
	  On some platforms, there is currently no way for the boot loader to
	  pass arguments to the kernel.  For these platforms, and for the cases
	  when you want to add some extra options to the command line or ignore
	  the default command line, you can supply some command-line options at
	  build time by entering them here.  In other cases you can specify
	  kernel args so that you don't have to set them up in board prom
	  initialization routines.

	  For more information, see the CMDLINE_BOOL and CMDLINE_OVERRIDE
	  options.

config CMDLINE_OVERRIDE
	bool "Built-in command line overrides firmware arguments"
	depends on CMDLINE_BOOL
	help
	  By setting this option to 'Y' you will have your kernel ignore
	  command line arguments from firmware or second stage bootloader.
	  Instead, the built-in command line will be used exclusively.

	  Normally, you will choose 'N' here.

config SB1XXX_CORELIS
	bool "Corelis Debugger"
	depends on SIBYTE_SB1xxx_SOC
	select DEBUG_KERNEL if !COMPILE_TEST
	select DEBUG_INFO if !COMPILE_TEST
	help
	  Select compile flags that produce code that can be processed by the
	  Corelis mksym utility and UDB Emulator.

config SPINLOCK_TEST
	bool "Enable spinlock timing tests in debugfs"
	depends on DEBUG_FS
	default n
	help
	  Add several files to the debugfs to test spinlock speed.

config SCACHE_DEBUGFS
	bool "L2 cache debugfs entries"
	depends on DEBUG_FS
	help
	  Enable this to allow parts of the L2 cache configuration, such as
	  whether or not prefetching is enabled, to be exposed to userland
	  via debugfs.

	  If unsure, say N.

menuconfig MIPS_CPS_NS16550_BOOL
	bool "CPS SMP NS16550 UART output"
	depends on MIPS_CPS
	help
	  Output debug information via an ns16550 compatible UART if exceptions
	  occur early in the boot process of a secondary core.

if MIPS_CPS_NS16550_BOOL

config MIPS_CPS_NS16550
	def_bool MIPS_CPS_NS16550_BASE != 0

config MIPS_CPS_NS16550_BASE
	hex "UART Base Address"
	default 0x1b0003f8 if MIPS_MALTA
	default 0
	help
	  The base address of the ns16550 compatible UART on which to output
	  debug information from the early stages of core startup.

	  This is only used if non-zero.

config MIPS_CPS_NS16550_SHIFT
	int "UART Register Shift"
	default 0
	help
	  The number of bits to shift ns16550 register indices by in order to
	  form their addresses. That is, log base 2 of the span between
	  adjacent ns16550 registers in the system.

config MIPS_CPS_NS16550_WIDTH
	int "UART Register Width"
	default 1
	help
	  ns16550 registers width. UART registers IO access methods will be
	  selected in accordance with this parameter. By setting it to 1, 2 or
	  4 UART registers will be accessed by means of lb/sb, lh/sh or lw/sw
	  instructions respectively. Any value not from that set activates
	  lb/sb instructions.

endif # MIPS_CPS_NS16550_BOOL

# These options are only for real kernel hackers who want to get their hands dirty.
config DEBUG_LL
	bool "Kernel low-level debugging functions (read help!)"
	depends on DEBUG_KERNEL
	help
	  Say Y here to include definitions of printascii, printch, printhex
	  in the kernel.  This is helpful if you are debugging code that
	  executes before the console is initialized.

	  Note that selecting this option will limit the kernel to a single
	  UART or semihosting definition, as specified below. Attempting to
	  boot the kernel image on a different platform *will not work*, so
	  this option should not be enabled for kernels that are intended to
	  be portable.

config DEBUG_LL_EXCEPT
	bool "Kernel low-level debugging of exceptions"
	depends on DEBUG_LL
	help
	  Say Y here to enable debugging prints for low-level exceptions.
	  This is helpful if you are debugging a early boot crash when
	  exceptions happens before trap_init(), or if you are debugging
	  SMP bringup code.

choice
	prompt "Kernel low-level debugging port"
	depends on DEBUG_LL

	config DEBUG_MIPS_UHI
		bool "Kernel low-level debugging via UHI semihosting"
		help
		  Say Y here if you want kernel low-level debugging support
		  via MIPS UHI semihosting.

	config DEBUG_LL_UART_8250
		bool "Kernel low-level debugging via 8250 UART"
		select DEBUG_LL_UART
		help
		  Say Y here if you wish the debug print routes to direct
		  their output to an 8250 UART.  You can use this option
		  to provide the parameters for the 8250 UART rather than
		  selecting one of the platform specific options below if
		  you know the parameters for the port.

	config DEBUG_BOSTON_UART
		bool "Kernel low-level debugging messages via Boston UART"
		depends on MIPS_GENERIC_KERNEL
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on IMG Boston board.

	config DEBUG_MALTA_UART
		bool "Kernel low-level debugging messages via malta UART"
		depends on MIPS_MALTA
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on MTI malta board.

	config DEBUG_AR71XX_UART
		bool "Kernel low-level debugging messages via AR71XX UART"
		depends on ATH79
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on AR71xx based platforms.

	config DEBUG_LOONGSON3_UART
		bool "Kernel low-level debugging messages via Loongson-3 UART"
		depends on MACH_LOONGSON64
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Loongson-3 systems.

	config DEBUG_LOONGSON2K_UART
		bool "Kernel low-level debugging messages via Loongson 2K UART"
		depends on MACH_LOONGSON64
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on Loongson-2K SoCs.

	config DEBUG_INGENIC_UART
		bool "Kernel low-level debugging messages via Ingenic UART"
		depends on MACH_INGENIC_SOC
		select DEBUG_UART_8250
		help
		  Say Y here if you want kernel low-level debugging support
		  on uart0 of Ingenic SoCs.

	config DEBUG_ALCHEMY_UART
		bool "Kernel low-level debugging messages via Alchemy UART"
		depends on MIPS_ALCHEMY
		select DEBUG_LL_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on uart of alchemy SoCs.

	config DEBUG_AR933X_UART
		bool "Kernel low-level debugging messages via Alchemy UART"
		depends on MIPS_ALCHEMY
		select DEBUG_LL_UART
		help
		  Say Y here if you want kernel low-level debugging support
		  on uart of AR933X SoCs.

endchoice

config DEBUG_LL_INCLUDE
	string
	default "debug/8250.S" if DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default "debug/alchemy.S" if DEBUG_ALCHEMY_UART
	default "debug/uhi.S" if DEBUG_MIPS_UHI
	default "debug-macro.S"

# Compatibility options for 8250
config DEBUG_UART_8250
	bool
	select DEBUG_LL_UART

config DEBUG_LL_UART
	bool

config DEBUG_UART_FLOW_CONTROL
	bool "Enable flow control (CTS) for the debug UART"
	depends on DEBUG_LL_UART
	default n
	help
	  Some UART ports are connected to terminals that will use modem
	  control signals to indicate whether they are ready to receive text.
	  In practice this means that the terminal is asserting the special
	  control signal CTS (Clear To Send). If your debug UART supports
	  this and your debug terminal will require it, enable this option.

config DEBUG_UART_PHYS
	hex "Physical base address of debug UART"
	depends on DEBUG_LL_UART
	default 0x17ffe000 if DEBUG_BOSTON_UART
	default 0x1fd003f8 if DEBUG_MALTA_UART
	default 0x18020000 if DEBUG_AR71XX_UART
	default 0x1fd003f8 if DEBUG_LOONGSON3_UART
	default 0x1fe00000 if DEBUG_LOONGSON2K_UART
	default 0x10030000 if DEBUG_INGENIC_UART
	default 0x11100000 if DEBUG_ALCHEMY_UART
	default 0x18020000 if DEBUG_AR933X_UART
	help
	  This is the physical base address of the debug UART. It must be
	  accessible from unmapped kernel space (i.e. KSEG1 for 32bit kernels
	  or XKPHYS for 64bit kernels).

config DEBUG_UART_8250_SHIFT
	int "Register offset shift for the 8250 debug UART"
	depends on DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default 1 if DEBUG_MALTA_UART || DEBUG_LOONGSON3_UART || \
		DEBUG_LOONGSON2K_UART
	default 2

config DEBUG_UART_8250_WIDTH
	int "Register width for the 8250 debug UART"
	depends on DEBUG_LL_UART_8250 || DEBUG_UART_8250
	default 1

config DEBUG_ZBOOT
	bool "Enable compressed kernel debugging via DEBUG_LL output"
	depends on DEBUG_LL && SYS_SUPPORTS_ZBOOT
	help
	  Say Y here if you want to enable debugging of a compressed kernel
	  via the DEBUG_LL output.  This is useful if you are debugging
	  decompressor issues.

	  If unsure, say N.

config DEBUG_ZBOOT_EXCEPT
	bool "Enable compressed kernel debugging of exceptions"
	depends on DEBUG_ZBOOT
	help
	  Say Y here if you want to enable debugging of exceptions happen
	  during decompression of a compressed kernel via the DEBUG_LL output.

	  If unsure, say N.
